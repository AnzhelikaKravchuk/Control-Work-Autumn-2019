
# Control Work. Winter 2019. 1 course. 1a group

1. Реализовать функцию

        int nextSmallerThan(int);

которая находит для заданного положительного числа ближайшее предыдущее число, состоящее из тех же цифр, что и заданное, или -1, если такого числа не существует. Проверить работу функции на различных данных, используя функцию
        
        void nextSmallerTests();

и следующие тестовые данные

         nextSmaller(21) == 12
         nextSmaller(531) == 513
         nextSmaller(2071) == 2017
         nextSmaller(9) == -1
         nextSmaller(111) == -1
         nextSmaller(135) == -1
         nextSmaller(1027) == -1
         nextSmaller(1113211111) == 1113121111
         nextSmaller(11191234567) == 79654321
         nextSmaller(173582) == 173528
         nextSmaller(4321234) == 4314322
         nextSmaller(2147483647) == 2147483476

2. Реализовать функцию 

         int* encoding(const char * source, const char * rule);

возвращающую массив целых чисел как результат кодирования строки *source* (массив char-ов) с использованием строки-правила кодирования *rule* (массив char-ов) и функцию

         char* decoding(const int * source, const char * rule);

принимающую в качестве параметров массив чисел *source*, в котором закодирована строка и строку-правило декодирования *rule* (массив char-ов) и возаращающую строку-результат декодирования (массив char-ов).

Строку-правило для кодирования построить на основе строки **"abcdefghijklmnopqrstuvwxyz"**, состоящей из символов английского алфивита, расположенных в алфавитном порядке в нижнем регистре. 

При кодировании английского текста, который может содержать любые символа, помимо символов алфавита (при этом символы алфавита могут быть как в нижнем, так и в верхнем регистре) соблюдать следующие правила
        - для кодирования символа алфавита используется строка-правило (определена выше), согласно которому в числовой последовательности каждое число соответствует порядковому номеру буквы в перевернутом алфавите "zyxwvutsrqponmlkjihgfedcba" ('z' = 1, 'a' = 26 и т.д.);
        - для кодирования символа, не являющегося символом алфавита используется его ASCII-код.

Например, согласно методу кодирования строка **"Learn C++!"** кодируется массивом **{15, 22, 26, 9, 13, 32, 24, 43, 43, 33}**, а декодирования, соответственно, наоборот.

Равенство строк проверяется с помощью функции 

        bool equals(const char * lhs, const char * rhs);

Равенство массивов проверяется с помощью функции 

        bool equals(const int * lhs, const int * rhs);
        
Работу функций проверить с помошью тестов.
